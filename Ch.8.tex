\chapter{Concluding remarks}
Point defects are the outliers in highly ordered crystalline lattice, they break translational symmetry and induce electron-defect scatterings in quantum materials. While vacancies, interstitials, and substitutions from different chemical compounds are all called point defects, they possess different characteristics and scatter differently. Studying these defect-specific scatterings is the key to bridge atomic-scale observations to macroscopic transport properties. 

As formulated in Section \ref{sec:scopeofstudy}, this thesis aims to address some of the challenges in resolving defect-specific information in quantum materials. Specifically, the thesis sought to (i) quantify defect populations in topological semimetals with statistical rigor, and (ii) develop and apply a computational framework capable of resolving defect-specific scattering features from quasiparticle interference (QPI) data.

To address the first aim, a statistical framework based on multinomial analysis of STM topographies was introduced and applied to PtSn\textsubscript{4}. This enabled quantitative extraction of defect-specific densities across different growth conditions. The analysis revealed that PtSn\textsubscript{4} exhibits exceptionally low intrinsic defect densities—even under rapid cooling—clarifying that its extraordinary transport properties stem primarily from crystalline perfection rather than exotic topological suppression of scattering.

To address the second aim, a convolutional framework for \ac{QPI} spectroscopy was formulated, and a new Multi-Channel Sparse Blind Deconvolution (MC-SBD) algorithm was developed. Its performance was validated first on synthetic datasets, where it successfully disentangled overlapping scattering channels from various defects, and then applied to experimental systems, where various levels of success were achieved. In ZrSiTe, the algorithm resolved four distinct defect types and revealed evidence for previously missing floating-band scattering, demonstrating that the approach provides access to defect-specific scattering channels inaccessible to conventional FT-QPI. However, based on the performance analysis on both synthetic and real data, the algorithm can produce robust and reliable results only when the input data reach certain standards. Together with other remarks on parameter settings, I will present a practical guide here. 

\section{A practical guide to perform MC-SBD on real data}
Although we will not elaborate in detail on best practices for scanning tunneling spectroscopy (STS), it is important to emphasize that the algorithm’s success depends critically on acquiring high-quality grid maps. This requires shaping a stable tip, minimizing mechanical and electronic noise, and carefully maintaining experimental conditions—for example, choosing appropriate bias voltage and current setpoints, optimizing the feedback loop, and adjusting lock-in modulation parameters to maximize signal-to-noise while avoiding distortion. These foundational practices should always be followed. In addition, particular attention must be paid to avoiding structured noise, which can severely degrade algorithm performance.

\subsubsection{grid map taking}
For optimal results, the grid map should ideally cover a region where the number of occurrences for each defect type of interest exceeds a threshold value, denoted as $N^{\text{critical}}$. Because defect types often vary significantly in their densities, it may be challenging to identify regions where all defect types are sufficiently represented. In such cases, it is advisable to focus on the defect types of greatest interest and select regions where these specific types surpass their respective $N^{\text{critical}}$.

The value of $N^{\text{critical}}$ depends on the signal-to-noise ratio (SNR) of the measurement, which can be estimated by comparing the contrast strength of the QPI pattern around a defect relative to the pristine background. The estimated $N^{\text{critical}}$ based on the SNR is given in the Figure. \ref{fig:KS_vs_N}, which was established in the synthetic data environment. However, due to additional complexities in experimental data, $N^{\text{critical}}$ shown in Figure. \ref{fig:KS_vs_N} is often underestimated. To mitigate this, it is beneficial to include a larger number of defects by either (i) identifying regions with higher local defect density, or (ii) increasing the physical coverage of the grid. The latter option may be constrained by cryogenic holding time; one possible trade-off is to reduce the real-space resolution. Additionally, as shown in Figures \ref{fig:phase_space} and \ref{fig:phase_spaceN=3}, excessively high local defect density (e.g., $\geq$ 0.1 defects per lattice site) leads to reconstruction failure, so regions with defect clustering should be avoided.

\subsubsection{kernel selection}
The algorithm allows users to specify the number of kernels and their sizes to deconvolve. The number of kernels should generally match the number of distinct QPI patterns corresponding to the defect types of interest; note that in the case of the same defect with different in-plane rotations, they are considered to have distinct QPI patterns, and we should use multiple kernels. Unrelated defect types can be ignored, as demonstrated in our analyses of LiFeAs (Figure \ref{fig:LiFeAs}) and ZrSiTe (Figure \ref{fig:ZrSiTe1}), where we used two kernels. However, if unwanted defects exhibit strong contrast, they can interfere with the reconstruction. In such cases, we recommend suppressing their signal intensity using truncated Gaussian masks during the preprocessing stage. 

When choosing kernel sizes, there are two considerations. First, recall the larger kernel sizes will increase the degeneracy space and poses a harder problem for the algorithm, as we discussed in Section 5.2.1, and shown in \ref{fig:ch6_t&s}; and the smallest kernel size should be big enough to cover the whole distinct QPI pattern in the observation $Y$, with the kernel edge being where the QPI signal amplitude meets the noise level. Second, due to the denoising capacity of the algorithm, the output kernel has a lower noise level and could uncover QPI features further from the defect center that was originally inaccessible from the observation $Y$; this sets the upper bound of the kernel size, with which we could retrieve more information in real space and better resolution in momentum space. The user is therefore recommended to start from the smallest and incrementally increase the kernel size until the algorithm fails to produce high-quality outputs. In terms of the kernel shape, while all the kernels used in this chapter are square, the algorithm allows for rectangular kernels, which could be useful for scattering features with spatial anisotropy.

\subsubsection{parameter setting and algorithm run}
As described earlier, the algorithm is typically run first on a single energy slice (“slice run”), followed by a full energy stack (“block run”) once success has been achieved on the slice. The block run benefits from the output activation maps of the slice run, which can be used as an initial guess. Since defect activations are assumed constant across energy, this initialization is often close to the global minimum of the data fidelity term and significantly improves the block run’s success rate.

Finally, note that the sparsity regularization parameter $\lambda_i^{\text{block}}$ for each kernel type $i$ should be scaled relative to the number of energy slices. Specifically, if the slice run used a value of $\lambda_i^{\text{slice}}$, then the block run with $N_{slices}$ slices should use:
\begin{equation}
	\lambda_i^{\text{block}} = \sqrt{N_{slices}}\lambda_i^{\text{slice}}
\end{equation}
A detailed discussion of the sparsity regularizar $\lambda$ can be reviewed in Section 5.3.2. 

\section{outlook}
As a new data processing technique, the MC-SBD algorithm opens new ways to interpret experimental data—both by revisiting old studies and by guiding the design of new ones based on the practical guidelines established above. The four materials explored in this thesis represent only a small fraction of the potential applications of this algorithm. In the following, I outline several possible future directions.

One important application is the study of materials with band-selective scattering. In the ZrSiX family (X = S, Se, Te), for example, Zr-site defects are observed to couple strongly to the floating band, while other defects play little or no role in this process \cite{butlerQuasiparticleInterferenceZrSiS2017}\cite{buVisualizationElectronicTopology2018}\cite{stuartScanningTunnellingMicroscopy2021}. This demonstrates how certain defects can act as the main channels for scattering into particular electronic states. MC-SBD provides the tools to isolate these contributions and compare them across different defect types and materials.

From here, a natural step forward is to build a defect–scattering fingerprint database. Conventional QPI measurements capture the combined scattering from many or all defects in a material, but with MC-SBD this signal can be separated into fingerprints specific to each defect species. Such a dataset would be valuable in two main ways. First, it would provide a rigorous testing ground for theories of defect scattering, allowing direct comparison between predicted behaviors—such as the role of orbital character or local symmetry—and experimentally resolved data. Second, it would enhance our ability to perform defect engineering: by identifying which defects couple beneficially or detrimentally to particular bands, we could guide synthesis to favor desirable defects or suppress harmful ones, thereby tuning material properties in a controlled way.

In addition, by resolving interference from individual defects directly in real space, the algorithm preserves phase information that is lost in traditional Fourier-based analysis. This opens the door to phase-sensitive studies of scattering in materials such as unconventional superconductors. For example, one could identify Bogoliubov quasiparticle interference patterns governed by selection rules reflecting sign-reversed order parameters—information that is inaccessible using standard QPI techniques \cite{chiSignInversionSuperconducting2014}.

Another potential application is the development of a defect detection mechanism. Once the scattering feature of a specific defect type is established, it can be used as an initial kernel guess; the resulting activation map then represents the spatial distribution of that defect type. This is particularly useful when defects occur at high density, where manual counting becomes both exhausting and unreliable. A limitation is that grid map measurements are time-consuming, but this can be mitigated by using STM topographies as input. Since topographies are also 2D datasets, analogous to grid-map slices, the algorithm can in principle operate on them as well. Moreover, topography acquisition is much faster and covers larger areas with higher defect occurrence, further increasing the reliability of the algorithm’s performance.

Finally, at its core the MC-SBD algorithm is an optimization method designed to identify repetitive patterns hidden within complex data. It can therefore be applied to any measurement described as a convolution of local 2D kernels with relatively sparse sources. This abstraction implies that any imaging tool could, in principle, benefit from the algorithm, provided the system under study contains repeating units worth characterizing. For instance, in cryo-electron microscopy of self-assembled silica nanocages \cite{maSelfassemblyHighlySymmetrical2018}, thousands of noisy 2D images of ultrasmall repeating cages are demixed and reconstructed into their underlying structure—a problem that aligns directly with the strengths of MC-SBD. In astronomy, stars in a field can be thought of as repeating point sources, each blurred by the telescope’s point-spread function. When many such sources overlap, the task is to demix and reconstruct the individual star patterns from the combined measurement—a setting directly analogous to the way MC-SBD separates overlapping kernels.
